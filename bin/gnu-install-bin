#! /usr/bin/env ruby
#
# Run as
#
#   sudo /bin/bash -c "rm -rf hello" ; time ./guix-hello-2.10-x86_64/traveling-ruby-20141215-2.1.5-linux-x86_64/bin/ruby ./guix-hello-2.10-x86_64/gnu-install-bin -v -d hello
#

require 'optparse'
require 'fileutils'

options = {strategy: :default, show_help: false, verbose: false, debug: false}

begin

  rootpath = File.dirname(__FILE__)
  $: << File.join(rootpath,'lib')

  $stderr.print "gnu-install-bin 0.0.1-pre1 Copyright (C) 2017 Pjotr Prins <pjotr.prins@thebird.nl>\n\n"
  USAGE =<<EOU

  gnu-install-bin is a one-click binary software installer

EOU

  require "messages"
  require "exec"

  opts = OptionParser.new do |o|
    o.banner = "Usage: #{File.basename($0)} [options] target-dir\n\n"

    o.separator "\n\tVerbosity:\n\n"

    o.on("--strategy default,fixed,expand", String, "patchelf command") do |s|
      options[:strategy] = s.to_sym
    end

    o.on("--patchelf exec", String, "patchelf command") do |p|
      options[:patchelf] = p
    end

    o.on("--guix-relocate exec", String, "guix-relocate command") do |p|
      options[:guix_relocate] = p
    end

    o.on("-q", "--quiet", "Run quietly") do |q|
      options[:quiet] = q
    end

    o.on("-v", "--verbose", "Run verbosely") do |v|
      options[:verbose] = v
    end

    o.on("-d", "--debug", "Show debug messages") do |d|
      if not options[:debug]
        options[:debug] = true
      else
        options[:debug2] = true
      end
    end

    o.separator ""

    o.on_tail('-h', '--help', 'Display this help and exit') do
      options[:show_help] = true
    end
  end

  begin
    opts.parse!(ARGV)

    if options[:show_help]
      print opts
      print USAGE
    end

  rescue OptionParser::InvalidOption => e
    options[:invalid_argument] = e.message
  end

  include Messages
  init(options)
  include Exec
  init(options)

  info(ARGV)
  target_dir1 =
    if ARGV.size > 0
      ARGV.shift
    else
      error "No target-dir specified"
    end

  require 'installer'
  include Installer

  # ==== Processing starts here
  info("Got target dir #{target_dir1}")
  target_dir = File.expand_path(target_dir1)
  info("Expand target dir to #{target_dir} and create")
  Dir.mkdir target_dir

  origin_dir = rootpath

  info "Checking directory structure of #{origin_dir}"
  if not File.directory?('./gnu/store')
    error "This is odd: /gnu/store does not existing in package directory #{origin_dir}"
  end

  info "Processing files..."
  recs = {}

  # ---- Create a list of all file, symlink and dir entries and validate
  #      they exist. A list of embedded ./gnu/store references is also
  #      stored.

  Dir['**/*'].each_with_index do | fn,i |
    # break if i > 1000 # for testing
    if fn =~ /^install/ # skip the installer files
      debug "Skipping #{fn}"
      next
    end
    if fn =~ /\/share\/zoneinfo\/posix$/
      warn "Symlink #{fn} is not valid"
      next
    end
    mode = File.stat(fn).mode

    addrec = lambda { |fn,rec|
      if recs[fn] != nil
        error "#{fn} already processed"
      end
      rec[:mode] = mode
      debug fn
      debug rec
      recs[fn] = rec
    }

    if File.directory? fn
      if fn == "gnu/store" or fn == "lib"
        addrec.call(fn, { type: :skip })
      else
        addrec.call(fn,{ type: :dir})
      end
      next
    end
    if File.symlink? fn
      link = File.readlink fn
      if link !~ /^\//
        addrec.call(fn, { type: :symlink, link: link } )
      else
        # addrec.call(fn, { type: :absolute_symlink, link: link } )
        # if not do_skip.include?(fn)
          error "Symlink is pointing outside the store: #{fn} => #{link}"
        # end
      end
      next
    end
    refs = get_all_refs(fn, addrec)
    next if refs == nil
    if !text_file? fn
      addrec.call(fn, { type: :binary, refs: refs } )
    else
      addrec.call(fn, { type: :text, refs: refs } )
    end
  end

  # ---- Resolve all references and create new relative target
  info "Resolving references..."
  refs = {}
  recs.each do | fn, rec |
    if fn =~ /gnu\/store\/./
      refs[fn] = reduce_store_path(fn)
    end
  end

  targetref = lambda { |path|
    if refs[path]
      target_dir + "/" + refs[path]
    else
      target_dir + "/" + path
    end
  }

  # ---- Copy files
  info "Copy files..."
  recs.each do | fn, rec |
    # p [fn,rec]
    tpath = targetref.call(fn)
    case rec[:type]
    when :symlink then
      debug "Symlink for #{tpath}"
      Dir.chdir(File.dirname(tpath)) { |p|
        FileUtils.symlink rec[:link], tpath
      }
    when :file, :binary, :text then
      debug "Copy to file #{tpath}"
      FileUtils.copy fn, tpath
    when :dir then
      debug "Create directory #{tpath}"
      Dir.mkdir tpath
    when :skip then
      debug "Skipping #{tpath}"
      next
    else
      error "Uknown type for #{fn}"
    end
  end

# ---- Rewrite contained references
  info "Rewrite references..."
  recs.select { |id, rec| rec[:refs] }.each do | fn,rec |
    # p [fn,rec]
    tpath = targetref.call(fn)
    case rec[:type]
    when :binary then
      debug "Relocate binary file #{tpath}"
      relocate_binary(tpath,rec[:refs],targetref)
    when :text then
      debug "Relocate text file #{tpath}"
      relocate_text(tpath,rec[:refs],targetref)
    else
      error "Uknown type for #{fn}"
    end
  end

  # ---- Set modes
  info "Set permissions..."
  recs.each do | fn, rec |
    if rec[:mode] and rec[:type] != :skip
      tpath = targetref.call(fn)
      # debug "Set permissions on #{tpath}"
      File.chmod(rec[:mode],tpath)
    end
  end

  info "Final check of relative paths..."
  recs.each do | fn, rec |
    if rec[:mode] and rec[:type] != :skip and rec[:type] != :dir and fn !~ /-bash-static-/
      tpath = targetref.call(fn)
      result = shell "strings -t d #{tpath}|grep 'gnu/store/'"
      if result != ""
        warning result
        warning "File #{tpath} still contains reference(s) to the store"
      end
    end
  end

# ---- Check modes and warn on remaining references to /gnu/store

rescue => msg
  if options[:debug]
    raise
  else
    $stderr.print "Error: ",msg,"\n"
    exit 1
  end
end

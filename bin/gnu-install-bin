#! /usr/bin/env ruby

require 'optparse'

options = {show_help: false, verbose: false, debug: false}

begin

  rootpath = File.dirname(__FILE__)
  $: << File.join(rootpath,'lib')

  $stderr.print "gnu-install-bin 0.0.1-pre1 Copyright (C) 2016-2017 Pjotr Prins <pjotr.prins@thebird.nl>\n\n"
  USAGE =<<EOU

  gnu-install-bin is a one-click binary software installer

EOU

  require "messages"

  opts = OptionParser.new do |o|
    o.banner = "Usage: #{File.basename($0)} [options] [target-dir]\n\n"

    o.separator "\n\tVerbosity:\n\n"

    o.on("-q", "--quiet", "Run quietly") do |q|
      options[:quiet] = q
    end

    o.on("-v", "--verbose", "Run verbosely") do |v|
      options[:verbose] = v
    end

    o.on("--debug", "Show debug messages") do |d|
      options[:debug] = true
    end

    o.separator ""

    o.on_tail('-h', '--help', 'Display this help and exit') do
      options[:show_help] = true
    end
  end

  begin
    opts.parse!(ARGV)

    if options[:show_help]
      print opts
      print USAGE
    end

  rescue OptionParser::InvalidOption => e
    options[:invalid_argument] = e.message
  end

rescue => msg
  if options[:debug]
    raise
  else
    $stderr.print "Error: ",msg,"\n"
    exit 1
  end
end

include Messages

init(options)
debug(options)

info(ARGV)
target_dir1 =
  if ARGV.size > 0
    ARGV.shift
  else
    Dir.pwd
  end

require 'installer'
include Installer

# ==== Processing starts here
info("Got target dir #{target_dir1}")
target_dir = File.expand_path(target_dir1)
info("Expand target dir to #{target_dir} and create")
Dir.mkdir target_dir

origin_dir = rootpath
info "Changing into directory #{origin_dir}"
Dir.chdir(origin_dir)

info "Checking directory structure of #{origin_dir}"
if not File.directory?('./gnu/store')
  error "This is odd: /gnu/store does not existing in package directory #{origin_dir}"
end

info "Processing files"
recs = {}

Dir['**/*'].each do | fn |
  mode = File.stat(fn).mode

  addrec = lambda { |fn,rec|
    if recs[fn] != nil
      error "#{fn} already processed"
    end
    rec[:mode] = mode
    debug fn
    debug rec
    recs[fn] = rec
  }

  if File.directory? fn
    addrec.call(fn,{ type: :dir})
    next
  end
  if File.symlink? fn
    link = File.readlink fn
    if link !~ /^\//
      addrec.call(fn, { type: :symlink, link: link } )
    else
      addrec.call(fn, { type: :absolute_symlink, link: link } )
    end
    next
  end
  result = `strings -t d #{fn}|grep '/gnu/store/'`
  if result == ""
    addrec.call(fn, { type: :file } )
    next
  end
  info "Contains /gnu/store reference in #{fn}"
  debug result
  refs = result.split("\n").map {|line|
    parse_real_references(origin_dir, line)
  }
  if !text_file? fn
    addrec.call(fn, { type: :binary, refs: refs } )
  else
    addrec.call(fn, { type: :text, refs: refs } )
  end
end
